<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarea 3: Ejercicio en Cursor con Prompt Engineering - Fatima Gonz√°lez Romo</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="exercises.css">
    <script src="script.js"></script>
    <script>
        // Funci√≥n simple para cargar el c√≥digo
        document.addEventListener('DOMContentLoaded', function() {
            console.log('P√°gina cargada');
        });
    </script>
</head>
<body>
    <div class="container tarea3">
        <div class="header">
            <a href="index.html" class="back-btn">‚Üê Volver al Men√∫</a>
            <h1>Tarea 3: Ejercicio en Cursor con Prompt Engineering</h1>
            <p>Simulaci√≥n de arquitectura cloud.</p>
        </div>
        
        <div class="content">
            <!-- Informaci√≥n de la Tarea -->
            <div class="exercise-info">
                <h3>Instrucciones</h3>
                <ul>
                    <li>"Simula el dise√±o de una arquitectura cloud para una aplicaci√≥n de banca m√≥vil
                        usando una nube h√≠brida y funciones serverless. Muestra el c√≥digo del backend b√°sico y diagrama
                        arquitect√≥nico."</li>
                    <li>Anexar el c√≥digo generado, screenshots y una reflexi√≥n de 500 palabras sobre el uso de la IA para
                        crear la arquitectura.</li>
                </ul>
            </div>

            <!-- C√≥digo -->
            <div class="code-section">
                <h3>C√≥digo</h3>
                <h4>Simulaci√≥n de Arquitectura Cloud</h4>
                <div class="code-preview">
                    <div class="code-header-bar">
                        <div class="code-language">Python</div>
                    </div>
                    <pre class="code-display"><code>#!/usr/bin/env python3
"""
Arquitectura Cloud H√≠brida para Aplicaci√≥n de Banca M√≥vil
=========================================================

Este archivo contiene:
1. Dise√±o de arquitectura cloud h√≠brida con funciones serverless
2. C√≥digo backend b√°sico para operaciones bancarias
3. Diagrama arquitect√≥nico en formato Mermaid
4. Especificaciones de seguridad y escalabilidad

Autor: Fatima Gonzalez Romo
Fecha: 2024
"""

import json
import hashlib
import hmac
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from enum import Enum
import uuid

# =============================================================================
# 1. MODELOS DE DATOS Y ENUMERACIONES
# =============================================================================

class TransactionType(Enum):
    """Tipos de transacciones bancarias"""
    DEPOSIT = "deposit"
    WITHDRAWAL = "withdrawal"
    TRANSFER = "transfer"
    PAYMENT = "payment"
    LOAN_PAYMENT = "loan_payment"

class AccountType(Enum):
    """Tipos de cuenta bancaria"""
    CHECKING = "checking"
    SAVINGS = "savings"
    BUSINESS = "business"
    CREDIT = "credit"

class TransactionStatus(Enum):
    """Estados de transacciones"""
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

@dataclass
class User:
    """Modelo de usuario"""
    user_id: str
    email: str
    phone: str
    full_name: str
    created_at: datetime
    is_verified: bool = False
    kyc_status: str = "pending"

@dataclass
class Account:
    """Modelo de cuenta bancaria"""
    account_id: str
    user_id: str
    account_number: str
    account_type: AccountType
    balance: float
    currency: str = "USD"
    created_at: datetime = None
    is_active: bool = True

@dataclass
class Transaction:
    """Modelo de transacci√≥n"""
    transaction_id: str
    from_account_id: str
    to_account_id: Optional[str]
    amount: float
    transaction_type: TransactionType
    status: TransactionStatus
    description: str
    created_at: datetime
    processed_at: Optional[datetime] = None
    reference_number: str = None

# =============================================================================
# 2. SERVICIOS SERVERLESS - FUNCIONES LAMBDA/AZURE FUNCTIONS
# =============================================================================

class AuthenticationService:
    """Servicio de autenticaci√≥n serverless"""
    
    def __init__(self):
        self.secret_key = "banking_app_secret_key_2024"
    
    def generate_jwt_token(self, user_id: str, expires_in_hours: int = 24) -> str:
        """Genera token JWT para autenticaci√≥n"""
        header = {
            "alg": "HS256",
            "typ": "JWT"
        }
        
        payload = {
            "user_id": user_id,
            "iat": int(time.time()),
            "exp": int(time.time()) + (expires_in_hours * 3600)
        }
        
        # Simulaci√≥n de JWT (en producci√≥n usar√≠a jwt library)
        token = f"{json.dumps(header)}.{json.dumps(payload)}.{self._sign_token(header, payload)}"
        return token
    
    def _sign_token(self, header: dict, payload: dict) -> str:
        """Firma el token con HMAC"""
        message = f"{json.dumps(header)}.{json.dumps(payload)}"
        signature = hmac.new(
            self.secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        return signature
    
    def verify_token(self, token: str) -> Optional[str]:
        """Verifica y extrae user_id del token"""
        try:
            parts = token.split('.')
            if len(parts) != 3:
                return None
            
            payload = json.loads(parts[1])
            current_time = int(time.time())
            
            if payload.get('exp', 0) < current_time:
                return None
            
            return payload.get('user_id')
        except:
            return None

class AccountService:
    """Servicio de gesti√≥n de cuentas serverless"""
    
    def __init__(self):
        self.accounts_db = {}  # Simulaci√≥n de base de datos
    
    def create_account(self, user_id: str, account_type: AccountType) -> Account:
        """Crea una nueva cuenta bancaria"""
        account_id = str(uuid.uuid4())
        account_number = self._generate_account_number()
        
        account = Account(
            account_id=account_id,
            user_id=user_id,
            account_number=account_number,
            account_type=account_type,
            balance=0.0,
            created_at=datetime.now()
        )
        
        self.accounts_db[account_id] = account
        return account
    
    def get_account_balance(self, account_id: str) -> Optional[float]:
        """Obtiene el saldo de una cuenta"""
        account = self.accounts_db.get(account_id)
        return account.balance if account else None
    
    def update_balance(self, account_id: str, amount: float) -> bool:
        """Actualiza el saldo de una cuenta"""
        account = self.accounts_db.get(account_id)
        if not account:
            return False
        
        new_balance = account.balance + amount
        if new_balance < 0:
            return False  # Saldo insuficiente
        
        account.balance = new_balance
        return True
    
    def _generate_account_number(self) -> str:
        """Genera n√∫mero de cuenta √∫nico"""
        return f"ACC{int(time.time())}{uuid.uuid4().hex[:8].upper()}"

class TransactionService:
    """Servicio de transacciones serverless"""
    
    def __init__(self):
        self.transactions_db = {}
        self.account_service = AccountService()
    
    def process_transaction(self, transaction: Transaction) -> Dict[str, Any]:
        """Procesa una transacci√≥n bancaria"""
        result = {
            "success": False,
            "transaction_id": transaction.transaction_id,
            "message": "",
            "new_balance": None
        }
        
        try:
            # Validar transacci√≥n
            if not self._validate_transaction(transaction):
                result["message"] = "Transacci√≥n inv√°lida"
                return result
            
            # Procesar seg√∫n tipo
            if transaction.transaction_type == TransactionType.DEPOSIT:
                success = self.account_service.update_balance(
                    transaction.to_account_id, 
                    transaction.amount
                )
                if success:
                    transaction.status = TransactionStatus.COMPLETED
                    result["new_balance"] = self.account_service.get_account_balance(
                        transaction.to_account_id
                    )
                else:
                    transaction.status = TransactionStatus.FAILED
                    result["message"] = "Error al procesar dep√≥sito"
            
            elif transaction.transaction_type == TransactionType.WITHDRAWAL:
                success = self.account_service.update_balance(
                    transaction.from_account_id, 
                    -transaction.amount
                )
                if success:
                    transaction.status = TransactionStatus.COMPLETED
                    result["new_balance"] = self.account_service.get_account_balance(
                        transaction.from_account_id
                    )
                else:
                    transaction.status = TransactionStatus.FAILED
                    result["message"] = "Saldo insuficiente"
            
            elif transaction.transaction_type == TransactionType.TRANSFER:
                # Retirar de cuenta origen
                withdraw_success = self.account_service.update_balance(
                    transaction.from_account_id, 
                    -transaction.amount
                )
                
                if withdraw_success:
                    # Depositar en cuenta destino
                    deposit_success = self.account_service.update_balance(
                        transaction.to_account_id, 
                        transaction.amount
                    )
                    
                    if deposit_success:
                        transaction.status = TransactionStatus.COMPLETED
                        result["new_balance"] = self.account_service.get_account_balance(
                            transaction.from_account_id
                        )
                    else:
                        # Revertir retiro si falla el dep√≥sito
                        self.account_service.update_balance(
                            transaction.from_account_id, 
                            transaction.amount
                        )
                        transaction.status = TransactionStatus.FAILED
                        result["message"] = "Error al procesar transferencia"
                else:
                    transaction.status = TransactionStatus.FAILED
                    result["message"] = "Saldo insuficiente para transferencia"
            
            transaction.processed_at = datetime.now()
            self.transactions_db[transaction.transaction_id] = transaction
            
            if transaction.status == TransactionStatus.COMPLETED:
                result["success"] = True
                result["message"] = "Transacci√≥n procesada exitosamente"
            
        except Exception as e:
            transaction.status = TransactionStatus.FAILED
            result["message"] = f"Error interno: {str(e)}"
        
        return result
    
    def _validate_transaction(self, transaction: Transaction) -> bool:
        """Valida una transacci√≥n antes de procesarla"""
        if transaction.amount <= 0:
            return False
        
        if transaction.transaction_type in [TransactionType.DEPOSIT, TransactionType.TRANSFER]:
            if not transaction.to_account_id:
                return False
        
        if transaction.transaction_type in [TransactionType.WITHDRAWAL, TransactionType.TRANSFER]:
            if not transaction.from_account_id:
                return False
        
        return True

class NotificationService:
    """Servicio de notificaciones serverless"""
    
    def send_transaction_notification(self, user_id: str, transaction: Transaction) -> bool:
        """Env√≠a notificaci√≥n de transacci√≥n"""
        message = self._format_transaction_message(transaction)
        
        # Simulaci√≥n de env√≠o de notificaci√≥n
        print(f"üì± Notificaci√≥n enviada a usuario {user_id}: {message}")
        
        # En producci√≥n, aqu√≠ se integrar√≠a con:
        # - AWS SNS, Azure Notification Hubs, o Firebase Cloud Messaging
        # - Servicios de SMS como Twilio
        # - Servicios de email como SendGrid
        
        return True
    
    def _format_transaction_message(self, transaction: Transaction) -> str:
        """Formatea mensaje de transacci√≥n"""
        if transaction.transaction_type == TransactionType.DEPOSIT:
            return f"Dep√≥sito de ${transaction.amount:.2f} procesado exitosamente"
        elif transaction.transaction_type == TransactionType.WITHDRAWAL:
            return f"Retiro de ${transaction.amount:.2f} procesado exitosamente"
        elif transaction.transaction_type == TransactionType.TRANSFER:
            return f"Transferencia de ${transaction.amount:.2f} procesada exitosamente"
        else:
            return f"Transacci√≥n de ${transaction.amount:.2f} procesada exitosamente"

# =============================================================================
# 3. API GATEWAY Y CONTROLADORES
# =============================================================================

class BankingAPI:
    """API principal de la aplicaci√≥n bancaria"""
    
    def __init__(self):
        self.auth_service = AuthenticationService()
        self.account_service = AccountService()
        self.transaction_service = TransactionService()
        self.notification_service = NotificationService()
    
    def authenticate_user(self, email: str, password: str) -> Dict[str, Any]:
        """Autentica usuario y retorna token"""
        # Simulaci√≥n de autenticaci√≥n (en producci√≥n validar√≠a contra base de datos)
        if email and password:
            user_id = str(uuid.uuid4())
            token = self.auth_service.generate_jwt_token(user_id)
            
            return {
                "success": True,
                "token": token,
                "user_id": user_id,
                "expires_in": 86400  # 24 horas
            }
        
        return {
            "success": False,
            "message": "Credenciales inv√°lidas"
        }
    
    def get_account_balance(self, token: str, account_id: str) -> Dict[str, Any]:
        """Obtiene saldo de cuenta"""
        user_id = self.auth_service.verify_token(token)
        if not user_id:
            return {"success": False, "message": "Token inv√°lido"}
        
        balance = self.account_service.get_account_balance(account_id)
        if balance is None:
            return {"success": False, "message": "Cuenta no encontrada"}
        
        return {
            "success": True,
            "balance": balance,
            "account_id": account_id
        }
    
    def process_transaction(self, token: str, transaction_data: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa una transacci√≥n bancaria"""
        user_id = self.auth_service.verify_token(token)
        if not user_id:
            return {"success": False, "message": "Token inv√°lido"}
        
        # Crear objeto transacci√≥n
        transaction = Transaction(
            transaction_id=str(uuid.uuid4()),
            from_account_id=transaction_data.get("from_account_id"),
            to_account_id=transaction_data.get("to_account_id"),
            amount=float(transaction_data["amount"]),
            transaction_type=TransactionType(transaction_data["type"]),
            status=TransactionStatus.PENDING,
            description=transaction_data.get("description", ""),
            created_at=datetime.now(),
            reference_number=transaction_data.get("reference_number")
        )
        
        # Procesar transacci√≥n
        result = self.transaction_service.process_transaction(transaction)
        
        # Enviar notificaci√≥n si es exitosa
        if result["success"]:
            self.notification_service.send_transaction_notification(user_id, transaction)
        
        return result

# =============================================================================
# 4. CONFIGURACI√ìN DE ARQUITECTURA CLOUD
# =============================================================================

class CloudArchitectureConfig:
    """Configuraci√≥n de la arquitectura cloud h√≠brida"""
    
    def __init__(self):
        self.config = {
            "hybrid_cloud": {
                "public_cloud": {
                    "provider": "AWS/Azure/GCP",
                    "services": [
                        "API Gateway",
                        "Lambda Functions",
                        "DynamoDB/CosmosDB",
                        "S3/Blob Storage",
                        "CloudFront/CDN",
                        "SNS/Notification Hubs"
                    ]
                },
                "private_cloud": {
                    "provider": "On-premises/Private Cloud",
                    "services": [
                        "Core Banking System",
                        "Customer Database",
                        "Transaction Processing",
                        "Compliance & Audit Logs"
                    ]
                }
            },
            "serverless_functions": {
                "authentication": {
                    "runtime": "Python 3.9/Node.js 18",
                    "memory": "256 MB",
                    "timeout": "30 seconds",
                    "triggers": ["API Gateway", "Cognito"]
                },
                "account_management": {
                    "runtime": "Python 3.9",
                    "memory": "512 MB",
                    "timeout": "60 seconds",
                    "triggers": ["API Gateway", "DynamoDB Streams"]
                },
                "transaction_processing": {
                    "runtime": "Python 3.9",
                    "memory": "1024 MB",
                    "timeout": "120 seconds",
                    "triggers": ["API Gateway", "SQS"]
                },
                "notifications": {
                    "runtime": "Node.js 18",
                    "memory": "256 MB",
                    "timeout": "30 seconds",
                    "triggers": ["SNS", "EventBridge"]
                }
            },
            "security": {
                "encryption": {
                    "in_transit": "TLS 1.3",
                    "at_rest": "AES-256",
                    "key_management": "AWS KMS/Azure Key Vault"
                },
                "authentication": {
                    "method": "JWT + OAuth 2.0",
                    "mfa": "TOTP/SMS",
                    "session_timeout": "24 hours"
                },
                "compliance": {
                    "standards": ["PCI DSS", "SOX", "GDPR"],
                    "audit_logging": "CloudTrail/Azure Monitor",
                    "data_retention": "7 years"
                }
            },
            "scalability": {
                "auto_scaling": {
                    "min_capacity": 1,
                    "max_capacity": 1000,
                    "target_utilization": 70
                },
                "load_balancing": "Application Load Balancer",
                "caching": "Redis/ElastiCache",
                "cdn": "CloudFront/Azure CDN"
            }
        }
    
    def get_config(self) -> Dict[str, Any]:
        """Retorna la configuraci√≥n completa"""
        return self.config

# =============================================================================
# 5. DIAGRAMA ARQUITECT√ìNICO EN MERMAID
# =============================================================================

def generate_architecture_diagram() -> str:
    """Genera diagrama de arquitectura en formato Mermaid"""
    
    diagram = """
graph TB
    %% Cliente M√≥vil
    subgraph "Cliente M√≥vil"
        MA[Mobile App<br/>iOS/Android]
    end
    
    %% Nube P√∫blica
    subgraph "Nube P√∫blica (AWS/Azure/GCP)"
        subgraph "API Layer"
            AG[API Gateway<br/>Rate Limiting<br/>Authentication]
            LB[Load Balancer<br/>SSL Termination]
        end
        
        subgraph "Serverless Functions"
            AUTH[Authentication<br/>Lambda/Azure Function<br/>JWT Generation]
            ACC[Account Management<br/>Lambda/Azure Function<br/>Balance Queries]
            TXN[Transaction Processing<br/>Lambda/Azure Function<br/>Payment Processing]
            NOT[Notifications<br/>Lambda/Azure Function<br/>SMS/Email/Push]
        end
        
        subgraph "Data Layer"
            DB[(DynamoDB/CosmosDB<br/>User Data<br/>Account Info)]
            CACHE[(Redis/ElastiCache<br/>Session Cache<br/>Rate Limiting)]
            S3[S3/Blob Storage<br/>Documents<br/>Audit Logs]
        end
        
        subgraph "Messaging & Events"
            SQS[SQS/Service Bus<br/>Transaction Queue]
            SNS[SNS/Notification Hub<br/>Event Broadcasting]
            EB[EventBridge<br/>Event Routing]
        end
        
        subgraph "Security & Monitoring"
            KMS[KMS/Key Vault<br/>Encryption Keys]
            CW[CloudWatch/Azure Monitor<br/>Logging & Metrics]
            WAF[WAF<br/>DDoS Protection]
        end
    end
    
    %% Nube Privada/On-Premises
    subgraph "Nube Privada/On-Premises"
        subgraph "Core Banking"
            CBS[Core Banking System<br/>Mainframe/Legacy]
            TPS[Transaction Processing<br/>Real-time Processing]
        end
        
        subgraph "Compliance & Audit"
            AUDIT[Audit System<br/>Compliance Logs]
            KYC[KYC System<br/>Identity Verification]
        end
        
        subgraph "Private Data"
            PDB[(Customer Database<br/>Sensitive Data<br/>PII)]
            COMP[(Compliance Database<br/>Regulatory Data)]
        end
    end
    
    %% Conexiones Cliente
    MA -->|HTTPS/TLS 1.3| AG
    MA -->|Push Notifications| SNS
    
    %% Conexiones API Gateway
    AG -->|Route| AUTH
    AG -->|Route| ACC
    AG -->|Route| TXN
    AG -->|Route| NOT
    
    %% Conexiones Serverless
    AUTH -->|Store Tokens| CACHE
    AUTH -->|User Data| DB
    
    ACC -->|Account Data| DB
    ACC -->|Cache| CACHE
    ACC -->|Query| CBS
    
    TXN -->|Queue| SQS
    TXN -->|Process| TPS
    TXN -->|Update| DB
    TXN -->|Notify| SNS
    
    NOT -->|Send| SNS
    NOT -->|Log| S3
    
    %% Conexiones Data
    DB -->|Encrypt| KMS
    CACHE -->|Encrypt| KMS
    S3 -->|Encrypt| KMS
    
    %% Conexiones Privadas
    CBS -->|Sync| PDB
    TPS -->|Audit| AUDIT
    KYC -->|Verify| PDB
    
    %% Conexiones Seguras
    AG -->|VPN/Tunnel| CBS
    TXN -->|Secure API| TPS
    ACC -->|Encrypted| PDB
    
    %% Monitoreo
    CW -->|Monitor| AUTH
    CW -->|Monitor| ACC
    CW -->|Monitor| TXN
    CW -->|Monitor| NOT
    CW -->|Monitor| CBS
    
    %% Seguridad
    WAF -->|Protect| AG
    
    %% Estilos
    classDef publicCloud fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef privateCloud fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef serverless fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef data fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef security fill:#ffebee,stroke:#c62828,stroke-width:2px
    
    class AG,LB,AUTH,ACC,TXN,NOT,DB,CACHE,S3,SQS,SNS,EB,KMS,CW,WAF publicCloud
    class CBS,TPS,AUDIT,KYC,PDB,COMP privateCloud
    class AUTH,ACC,TXN,NOT serverless
    class DB,CACHE,S3,PDB,COMP data
    class KMS,CW,WAF,AUDIT security
    """
    
    return diagram

# =============================================================================
# 6. EJEMPLO DE USO Y DEMOSTRACI√ìN
# =============================================================================

def demonstrate_banking_system():
    """Demuestra el funcionamiento del sistema bancario"""
    
    print("üè¶ DEMOSTRACI√ìN DEL SISTEMA DE BANCA M√ìVIL")
    print("=" * 50)
    
    # Inicializar servicios
    api = BankingAPI()
    config = CloudArchitectureConfig()
    
    # 1. Autenticaci√≥n
    print("\\n1. üîê AUTENTICACI√ìN DE USUARIO")
    auth_result = api.authenticate_user("usuario@banco.com", "password123")
    print(f"Resultado: {json.dumps(auth_result, indent=2)}")
    
    if not auth_result["success"]:
        print("‚ùå Error en autenticaci√≥n")
        return
    
    token = auth_result["token"]
    user_id = auth_result["user_id"]
    
    # 2. Crear cuenta
    print("\\n2. üí≥ CREACI√ìN DE CUENTA")
    account = api.account_service.create_account(user_id, AccountType.CHECKING)
    print(f"Cuenta creada: {account.account_number}")
    print(f"Saldo inicial: ${account.balance}")
    
    # 3. Dep√≥sito
    print("\\n3. üí∞ PROCESAMIENTO DE DEP√ìSITO")
    deposit_data = {
        "to_account_id": account.account_id,
        "amount": 1000.00,
        "type": "deposit",
        "description": "Dep√≥sito inicial"
    }
    
    deposit_result = api.process_transaction(token, deposit_data)
    print(f"Resultado del dep√≥sito: {json.dumps(deposit_result, indent=2)}")
    
    # 4. Consulta de saldo
    print("\\n4. üìä CONSULTA DE SALDO")
    balance_result = api.get_account_balance(token, account.account_id)
    print(f"Saldo actual: {json.dumps(balance_result, indent=2)}")
    
    # 5. Retiro
    print("\\n5. üí∏ PROCESAMIENTO DE RETIRO")
    withdrawal_data = {
        "from_account_id": account.account_id,
        "amount": 250.00,
        "type": "withdrawal",
        "description": "Retiro en cajero"
    }
    
    withdrawal_result = api.process_transaction(token, withdrawal_data)
    print(f"Resultado del retiro: {json.dumps(withdrawal_result, indent=2)}")
    
    # 6. Mostrar configuraci√≥n de arquitectura
    print("\\n6. ‚òÅÔ∏è CONFIGURACI√ìN DE ARQUITECTURA CLOUD")
    print("Configuraci√≥n h√≠brida:")
    print(json.dumps(config.get_config()["hybrid_cloud"], indent=2))
    
    print("\\n‚úÖ Demostraci√≥n completada exitosamente!")

# =============================================================================
# 7. FUNCI√ìN PRINCIPAL
# =============================================================================

def main():
    """Funci√≥n principal que ejecuta la demostraci√≥n"""
    
    print("üöÄ INICIANDO SISTEMA DE BANCA M√ìVIL CON ARQUITECTURA CLOUD H√çBRIDA")
    print("=" * 80)
    
    # Mostrar diagrama de arquitectura
    print("\\nüìê DIAGRAMA DE ARQUITECTURA:")
    print("=" * 40)
    print("(El diagrama Mermaid se puede visualizar en herramientas como Mermaid Live Editor)")
    print("\\nC√≥digo del diagrama:")
    print(generate_architecture_diagram())
    
    # Ejecutar demostraci√≥n
    demonstrate_banking_system()
    
    print("\\n" + "=" * 80)
    print("üìã RESUMEN DE LA ARQUITECTURA:")
    print("=" * 80)
    print("""
    üèóÔ∏è ARQUITECTURA CLOUD H√çBRIDA:
    ‚îú‚îÄ‚îÄ üåê Nube P√∫blica (AWS/Azure/GCP)
    ‚îÇ   ‚îú‚îÄ‚îÄ API Gateway + Load Balancer
    ‚îÇ   ‚îú‚îÄ‚îÄ Funciones Serverless (Lambda/Azure Functions)
    ‚îÇ   ‚îú‚îÄ‚îÄ Bases de Datos NoSQL (DynamoDB/CosmosDB)
    ‚îÇ   ‚îú‚îÄ‚îÄ Cache Redis/ElastiCache
    ‚îÇ   ‚îú‚îÄ‚îÄ Almacenamiento S3/Blob Storage
    ‚îÇ   ‚îú‚îÄ‚îÄ Colas de Mensajes (SQS/Service Bus)
    ‚îÇ   ‚îú‚îÄ‚îÄ Notificaciones (SNS/Notification Hubs)
    ‚îÇ   ‚îî‚îÄ‚îÄ Monitoreo y Seguridad
    ‚îÇ
    ‚îî‚îÄ‚îÄ üè¢ Nube Privada/On-Premises
        ‚îú‚îÄ‚îÄ Sistema Core Banking (Mainframe)
        ‚îú‚îÄ‚îÄ Procesamiento de Transacciones
        ‚îú‚îÄ‚îÄ Base de Datos de Clientes (PII)
        ‚îú‚îÄ‚îÄ Sistema de Cumplimiento (KYC)
        ‚îî‚îÄ‚îÄ Auditor√≠a y Logs de Compliance
    
    üîß FUNCIONES SERVERLESS:
    ‚îú‚îÄ‚îÄ Authentication Service (JWT + OAuth 2.0)
    ‚îú‚îÄ‚îÄ Account Management Service
    ‚îú‚îÄ‚îÄ Transaction Processing Service
    ‚îî‚îÄ‚îÄ Notification Service (SMS/Email/Push)
    
    üîí SEGURIDAD:
    ‚îú‚îÄ‚îÄ Encriptaci√≥n TLS 1.3 en tr√°nsito
    ‚îú‚îÄ‚îÄ Encriptaci√≥n AES-256 en reposo
    ‚îú‚îÄ‚îÄ Gesti√≥n de claves con KMS/Key Vault
    ‚îú‚îÄ‚îÄ Autenticaci√≥n multifactor (MFA)
    ‚îú‚îÄ‚îÄ WAF para protecci√≥n DDoS
    ‚îî‚îÄ‚îÄ Cumplimiento PCI DSS, SOX, GDPR
    
    üìà ESCALABILIDAD:
    ‚îú‚îÄ‚îÄ Auto-scaling de funciones serverless
    ‚îú‚îÄ‚îÄ Load balancing autom√°tico
    ‚îú‚îÄ‚îÄ Cache distribuido
    ‚îú‚îÄ‚îÄ CDN para contenido est√°tico
    ‚îî‚îÄ‚îÄ Monitoreo en tiempo real
    """)

if __name__ == "__main__":
    main()</code></pre>
                </div>
            </div>

            <!-- Screenshots -->
            <div class="screenshots-section">
                <h3>Screenshots</h3>
                <div class="screenshot-gallery">
                    <div class="screenshot-item">
                        <img src="images/Tarea3/ModeloArquitectura.png" alt="Screenshot 1" onclick="openImageModal(this.src)">
                        <p>Screenshot 1</p>
                    </div>
                    <div class="screenshot-item">
                        <img src="images/Tarea3/PresentarArquitectura.png" alt="Screenshot 2" onclick="openImageModal(this.src)">
                        <p>Screenshot 2</p>
                    </div>
                    <div class="screenshot-item">
                        <img src="images/Tarea3/DemostracionBackend.png" alt="Screenshot 3" onclick="openImageModal(this.src)">
                        <p>Screenshot 3</p>
                    </div>
                </div>
            </div>

            <!-- Reflexi√≥n -->
            <div class="reflection-section">
                <h3>Reflexi√≥n</h3>
                <div class="reflection-content">
                    <p>En esta tarea se utiliz√≥ la Inteligencia Artificial para crear una arquitectura y backend de una aplicaci√≥n de banca m√≥vil. El uso de ella siempre es un desaf√≠o, ya que se le debe especificar muy bien lo que se quiere lograr, por ejemplo, tuve que agregar que todo fuera en un solo archivo para que realmente se cumpliera lo que necesitaba. Si no se da suficiente detalle en las instrucciones, la herramienta puede entregar resultados ambiguos o incompletos, lo cual refleja que todav√≠a requiere de una gu√≠a clara por parte del usuario para generar un producto √∫til.</p>

                    <p>En cuanto a la arquitectura que despleg√≥, parece tener sentido, debido a que puedo reconocer que tiene una secci√≥n de nube privada y una de nube p√∫blica. Por lo que, si bien no tengo certeza absoluta de que la arquitectura sea correcta, ya que no tengo experiencia en c√≥mo dise√±ar arquitecturas de software de manera profesional, a simple vista parece ser funcional y l√≥gica en su planteamiento. Esto me permiti√≥ visualizar c√≥mo se podr√≠a estructurar un sistema bancario real usando recursos en la nube de forma estrat√©gica.</p>

                    <p>Adem√°s, al observar la arquitectura generada, me ayud√≥ a darme cuenta de c√≥mo se pueden organizar los datos y servicios en los diferentes tipos de nube. Pude identificar que los datos privados, como la informaci√≥n sensible de los usuarios, se guardan en una base de datos ubicada en la nube privada. De la misma manera, los servicios o procesos cr√≠ticos como las transacciones, que requieren mayor seguridad y control, tambi√©n se encuentran en la nube privada. Mientras tanto, otros servicios que no son esenciales para la seguridad u operaci√≥n principal de un banco, como el acceso a la cuenta, la generaci√≥n de notificaciones o el env√≠o de correos electr√≥nicos, se alojan en la nube p√∫blica. Sin embargo, tambi√©n se puede notar que se consideraron aspectos de seguridad, ya que la arquitectura incluye secciones relacionadas con cifrado y protecci√≥n de la informaci√≥n.</p>

                    <p>Otro punto importante que observ√© es que la herramienta realmente no toma decisiones definitivas, sino que deja todo en un estado ambiguo, presentando opciones pero sin elegir ni implementar una en espec√≠fico. Por ejemplo, en la nube p√∫blica ofrece alternativas como AWS, Azure o GCP. Para la nube privada tambi√©n se puede optar por esas mismas plataformas o por infraestructura on-premise. En el caso de las bases de datos, dependiendo de la informaci√≥n que se quiera guardar, sugiere tecnolog√≠as como DynamoDB o CosmosDB; mientras que para el cach√© de la sesi√≥n propone Redis o ElastiCache. Estos son solo algunos ejemplos, pero en general, la arquitectura muestra un abanico de posibles tecnolog√≠as en lugar de seleccionar una soluci√≥n concreta, lo que demuestra que todav√≠a hace falta un criterio humano para la toma de decisiones.</p>

                    <p>Por otro lado, la implementaci√≥n del prompt tom√≥ alrededor de 5 minutos, lo cual es un tiempo muy reducido si lo comparo con lo que yo tardar√≠a en dise√±ar una arquitectura desde cero. Esta rapidez es una de las mayores ventajas de apoyarse en la Inteligencia Artificial. Por ello, considero que en el futuro lo m√°s probable es que se utilice esta tecnolog√≠a para generar un primer boceto de la arquitectura o del backend que se requiera, y que posteriormente los ingenieros de software o arquitectos lo revisen, ajusten y perfeccionen. De esta manera se podr√≠a reducir significativamente el tiempo de trabajo, ya que desde el inicio se tendr√≠a una base sobre la cual construir, en lugar de comenzar con una hoja en blanco.</p>

                    <p>En conclusi√≥n, el ejercicio me permiti√≥ reflexionar sobre el papel de la Inteligencia Artificial en el desarrollo de software y, en particular, en el dise√±o de arquitecturas en la nube. Aunque a√∫n no reemplaza la experiencia ni las decisiones t√©cnicas de un profesional, s√≠ representa una herramienta poderosa que puede ahorrar tiempo y servir como apoyo inicial en proyectos complejos como una aplicaci√≥n de banca m√≥vil.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para im√°genes -->
    <div id="imageModal" class="image-modal" onclick="closeImageModal()">
        <span class="image-modal-close" onclick="closeImageModal()">&times;</span>
        <div class="image-modal-content" onclick="event.stopPropagation()">
            <img id="modalImage" src="" alt="">
        </div>
    </div>
</body>
</html>